---
title: "Flappy Bird Clone"
excerpt: >
  A simple Flappy Bird clone built with Unity and C#, focused on physics-based
  controls, procedural pipe generation, and clean game loop design.
  <br/><img src="https://raw.githubusercontent.com/linh31072004123-blip/Flappy-Bird/62fcbe9159c8f5b351237a66660f436f65f05d76/flappybird.png" />
collection: portfolio
permalink: /portfolio/flappy-bird/
date: 2025-09-01
---

## Overview

**Flappy Bird** is a recreation of the classic arcade game, built in **Unity** using **C#**. This project helped me practice game physics, procedural generation, and clean, modular gameplay architecture.

Players tap/click to flap, navigating through randomly generated pipes that increase difficulty over time.

---

## ðŸŽ® Demo Video

<video width="100%" controls>
  <source src="/files/flappybird-demo.mov" type="video/quicktime">
  Your browser does not support the video tag.
</video>

## Game Play

<div style="display: flex; flex-wrap: wrap; gap: 12px; margin-top: 16px;">
  <img src="/images/flappybird-start.png" alt="Start Screen" style="width: 32%; border-radius: 10px;">
  <img src="/images/flappybird-gameplay.png" alt="Gameplay Screen" style="width: 32%; border-radius: 10px;">
  <img src="/images/flappybird-end.png" alt="End Screen" style="width: 32%; border-radius: 10px;">
</div>

---

## ðŸ§© Key Features

- **Rigidbody2D-based jump physics**
- **Procedural pipe generator** with height variance
- **Object pooling** for efficient 2D performance
- **Real-time scoring system**
- **Collision + game-over logic**
- **Clean game manager architecture**

---

## ðŸ”— GitHub Repository

ðŸ‘‰ [View the project on GitHub](https://github.com/linh31072004123-blip/Flappy-Bird)

---

## ðŸ›  Tools Used

- Unity
- C#
- Sprite-based animation
- Unity UI Toolkit
- GitHub version control

---

## ðŸŽ¯ Impact

Building this game strengthened my foundation in real-time interaction design.
Recreating a fast-paced 2D experience required careful tuning of responsiveness,
timing, and feedback loopsâ€”core elements that determine whether a
platformer feels satisfying or frustrating.

Implementing physics-based controls, procedural pipe generation, and
performance-aware object pooling taught me how subtle technical choices shape
player perception of challenge, flow, and fairness. Designing,
testing, and refining these systems helped me understand how to balance difficulty
while keeping the gameplay readable and engaging.

Overall, this project gave me hands-on experience building a complete and polished
2D gameplay loop, laying a strong foundation for my later work in 3D interaction
and more complex game systems.
